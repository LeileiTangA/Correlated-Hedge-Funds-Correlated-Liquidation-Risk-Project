%--------------------------------------------------------------%
%== The following code is to compare statistics DDM for FoFs ==%
%--------------------------------------------------------------%

timedepvar = xlsread('C:\Users\ias05106\OneDrive - University of Strathclyde\Desktop\Updated Hedge Fund Project\FoFData4SAS.xlsx');
    % timedepvar= [FoFID Year Distance1 Distance2 Return STD AUM Flow VIX BAA10YM AggLiq InnovLiq TradedLiq CRSP] %
    % This dataset is generated by using AliveDistanceLiquidation_FoF.m
 %-- Liquidated Funds Drop Reasons
 DropReason = xlsread('C:\Users\ias05106\OneDrive - University of Strathclyde\Desktop\Updated Hedge Fund Project\FundDropReasons.xlsx','DropReasons');
    % DropReason = [DropFundID DropReasonID]
    %-- Find EventID 0 = Alive; 1 = Liquidated
 FundID = unique(timedepvar(:,1));
 EventID = double(ismember(FundID,DropReason(:,1)));  % Finding those liquidated funds
    %-- Find DropID 0 = Alive; Others = Reasons of drop
 DropID = zeros(length(FundID),1);
 for i = 1:length(FundID)
     idx = find(DropReason(:,1)==FundID(i,1));
     if length(idx)~=0
         DropID(i,1)=DropReason(idx,2);
     else
         DropID(i,1)=0;
     end
 end
 Characters = [FundID EventID DropID];             
% timedepvar= [FoFID Year Distance1 Distance2 Return STD AUM Flow VIX BAA10YM AggLiq InnovLiq TradedLiq CRSP] % 
b=1;
counter=0;
while b<=size(timedepvar,1)
    counter=counter+1;
    f=find(timedepvar(:,1)==timedepvar(b,1)); % Time dependent variables
    F=find(Characters(:,1)==timedepvar(b,1)); % Character variables
    Char=Characters(F,:);
    temp=timedepvar(f,:);   % [FoFID Year Distance1 Distance2 Return STD AUM Flow VIX BAA10YM AggLiq InnovLiq TradedLiq CRSP] %
    numint=length(f);                         % Number of years
    container{counter}=[temp(:,1:9) [zeros(numint-1,1);Char(1,2)]];
                      % [FoFID Year Distance1 Distance2 Return STD AUM Flow VIX EventID]       
    f=[]; F=[]; Char=[]; temp=[]; 
    b=b+numint;
end
%Stack the datasets, container into one dataset
Result=[];
for i=1:length(container)
    d=container{i};
    Result=padconcatenation(Result,d,1);
    d=[]; 
end
Result(Result(:,2)==1998,4) = Result(Result(:,2)==1998,4)*10;

%---------------- KM Plot ----------- %
b=1;
counter=0;
while b<=size(Result,1)
    counter = counter + 1;
    n = length(find(Result(:,1)==Result(b,1)));
    KMdata(counter,:) = [n  Result(b+n-1,end) mean(Result(b:b+n-1,3).\Result(b:b+n-1,4))];
                           %[Duration   Event       DDM]
    b = b + n;
end

distance = KMdata(:,3); % DDM
time = KMdata(:,1);     % Duration
event = KMdata(:,2);    % Liquidation event

% Define row bins based on quantiles of distance (in reverse order)
    % quantiles = quantile(distance, 3); % Get 3 quantiles (25%, 50%, 75%)
    % row_bins = [max(distance), quantiles(3); % Reverse order
    %              quantiles(3), quantiles(2);
    %              quantiles(2), quantiles(1);
    %              quantiles(1), min(distance)];
    % 
    % % Define column bins based on time ranges
    % col_bins = [0, 4; % <4
    %             4, 7; % >=4 & <7
    %             7, 10; % >=7 & <10
    %             10, inf]; % >=10

    % Automatically define row bins based on quantiles of distance (in reverse order)
    quantiles = quantile(distance, linspace(0, 1, 5)); % Get 4 quantiles (0%, 25%, 50%, 75%, 100%)
    %row_bins = [quantiles(end:-1:2)', quantiles(end-1:-1:1)']; % Reverse order and pair quantiles
    row_bins = [quantiles(1:1:end-1)', quantiles(2:1:end)']; % A to Z order and pair quantiles
    % Automatically define column bins based on time ranges
    time_edges = [1, 4, 7, 10, 15,20,inf]; % Define edges for time bins
    col_bins = [time_edges(1:end-1)', time_edges(2:end)']; % Create column bins

    % Initialize the cross-classification table
    cross_table = zeros(4, 6); % 4 rows (distance quantiles) x 6 columns (time ranges)

    % Populate the table
    for i = 1:size(row_bins, 1)
        for j = 1:size(col_bins, 1)
            % Find indices of data points that fall into the current row and column bins
            row_mask = distance <= row_bins(i, 2) & distance >= row_bins(i, 1);
            col_mask = time >= col_bins(j, 1) & time < col_bins(j, 2);
            % Sum the event variable for the matching data points
            cross_table(i, j) = sum(event(row_mask & col_mask));
        end
    end
    % Display the table
    disp('FoF Cross-Classification Table:');
    disp(cross_table);
gamma = goodman_kruskal_gamma(cross_table);
    disp(gamma)
function gamma = goodman_kruskal_gamma(table)
    % Input: table - a 2D matrix representing the cross-classification table
    % Output: gamma - Goodman and Kruskal's gamma value

    [rows, cols] = size(table); % Get dimensions of the table
    C = 0; % Initialize concordant pairs
    D = 0; % Initialize discordant pairs

    % Loop through each cell to calculate C and D
    for i = 1:rows
        for j = 1:cols
            % Calculate concordant pairs (cells below and to the right)
            for k = i+1:rows
                for l = j+1:cols
                    C = C + table(i,j) * table(k,l);
                end
            end
            % Calculate discordant pairs (cells below and to the left)
            for k = i+1:rows
                for l = 1:j-1
                    D = D + table(i,j) * table(k,l);
                end
            end
        end
    end
    gamma = (C - D)/(C + D);
end





 
 
 






 


